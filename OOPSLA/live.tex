\section{Related Work}
\label{sec:live}

In 2012 Bret Victor gave a presentation \cite{bretVictorVideo} at the Canadian University Software Engineering Conference (CUSEC 2012), where he promotes the idea that ``creators need an immediate connection to what they create''. Today's programming practice is far from that ideal: we first write code, then we compile it, and only then can we test it. If we are not happy with our program's output, we debug, modify the code and repeat the process. Victor proposed a new approach to programming in his talk. Dubbed  {\emph {live programming}}, the approach would help programmers better understand the code that they are writing. Similar to WSIWYG text editors, their changes to their code would have immediately observable effects on its output. His influential talk sparked interest for live programming and led to a number of nicely annotated editors for live coding. However, in a follow-up paper \cite{victor2012} Victor stresses that the goal of live programming is not merely to have a have a fancy editor, but to help the developer better understand what the code is doing.

Live programming is not a new term: as a concept it has been popularly adopted in processing images and sound (under the name ``live coding'')\cite{mclean14}. However, the ideas of live programming have been present for a long time in the programming language literature under various different names. Hancock studied ``real-time programming'' \cite{HancockPhDThesis}, a live programming environment for helping children to learn how to program. His research was focused on developing a Logo-like programming environment for robotics. Hancock argues that ``the coordination of discrete and continuous process should be considered a central Big Idea in programming and beyond'' \cite{HancockPhDThesis}.

McDirmid, et. al. \cite{McDirmid13oopsla, BurckhardtFHMMTK13_PLDI, McDirmidE14} sparked renewed academic interest in live programming. Their approach combines editing and debugging to obtain the required level of interactivity and  feedback. However, the applications they consider are restricted to graphical user interfaces. They, too, claim that live programming is the direction that  future programming environments should follow: ``Live programming is emerging as the next big step in programming environments that will finally allow us to move beyond our Smalltalk-era IDEs into a more programmer-friendly future. However, existing live programming experiences are still not very useful - they dazzle us with live feedback but that feedback does not really help us write code!'' \cite{McDirmid13oopsla}.

Some forms of live programming are present in various programming environments under different names. These include interactive programming, just in time programming, conversational programming, and on-the-fly-programming. Perera \cite{Perera08Journal} introduces a programming model called ``declarative interaction'' where he develops  a philosophical model that should unify all the live programming concepts. A list of requirements that a system built on this model should support includes: (1) an interaction between code and data; (2) robustness: a program should be able to repair and reconfigure without restarting, (3) transparency: changes and updates in code behavior should be consistent with program semantics, and the system should be able to generate and provide provenance data explaining the changes; (4) modular: in order to ensure scalability of the approach, system interactions should be restricted within a given scope. However, this scope should be able to dynamically change. Despite his description of such a model, Perera concludes that we still ``lack a simple and coherent paradigm for building robust interactive systems''.

Such a system can help the user to write better code, and through continuous interaction the user will gain a more comprehensive understanding of their program. We believe that enriching a live programming paradigm with program synthesis concepts, such as programming by example, will accomplish all of the goals set by Perera's project.

